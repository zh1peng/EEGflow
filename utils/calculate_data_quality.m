function quality = calculate_data_quality(EEG, varargin)
% CALCULATE_DATA_QUALITY Computes a set of well-established EEG data quality metrics.
%   This function provides a comprehensive assessment of EEG data quality based on
%   metrics widely used in the literature. It serves as a more robust alternative
%   to simpler, single-value proxies for data quality.
%
%   The function computes metrics related to bad channels, rejected data segments,
%   signal power, and spectral characteristics.
%
% Syntax:
%   quality = utils.calculate_data_quality(EEG, 'param', value, ...)
%
% Input Arguments:
%   EEG         - (struct) An EEGLAB EEG structure. It is recommended to run this
%                 function after a preprocessing pipeline that identifies bad
%                 channels and epochs (e.g., using `prep.remove_bad_channels`
%                 and `prep.remove_bad_epoch`), as it leverages the output from
%                 those functions.
%
% Optional Parameters (Name-Value Pairs):
%   'line_freqs' - (numeric array, default: [50, 60])
%                  The line frequencies (e.g., 50 Hz, 60 Hz) for which to calculate
%                  power. The function will produce a separate metric for each.
%
%   'chan_exclude' - (cellstr, default: {})
%                  A cell array of channel labels to exclude from all channel-based
%                  quality calculations (e.g., GFP, amplitude spread, spectral metrics,
%                  and window-based cleaning). For example, {'EOG1', 'EOG2'}.
%
%   --- Parameters for clean_windows ---
%   'clean_maxbadchan' - (numeric, default: 0.2)
%                  The maximum proportion of bad channels per time window.
%
%   'clean_powertol' - (numeric array, default: [-3.5, 5])
%                  The power tolerance in standard deviations.
%
%   'clean_winlen' - (numeric, default: 1)
%                  The length of the sliding window in seconds.
%
%   'clean_winov' - (numeric, default: 0.66)
%                  The window overlap proportion.
%
% Output Structure:
%   The output is a single struct `quality` containing the following metrics:
%
%   --- Channel-based Metrics ---
%   .percent_bad_channels - (numeric) Percentage of channels marked as bad.
%       - Thresholds: <5% (Good), 5-15% (Acceptable), >15% (Poor)
%       - Note: Requires `EEG.etc.EEGdojo.BadChanSummary` and `EEG.urchanlocs`
%         which are generated by `prep.remove_bad_channels`.
%
%   --- Epoch-based Metrics ---
%   .percent_rejected_epochs - (numeric) Percentage of epochs rejected.
%       - Thresholds: <10% (Good), 10-25% (Acceptable), >25% (Poor)
%       - Note: Requires `EEG.etc.EEGdojo.BadEpochIdx` from `prep.remove_bad_epoch`.
%         Returns NaN for continuous data.
%
%   --- Global Signal Metrics ---
%   .global_field_power_std - (numeric) Standard deviation of the Global Field Power (GFP).
%       - Interpretation: A measure of overall signal variability. Higher values may
%         indicate more noise or artifact. Compare relative to other recordings in the
%         same study.
%
%   --- Amplitude Spread Proxy ---
%   .amplitude_spread_proxy - (numeric) A proxy for data quality based on signal amplitude spread.
%       - Interpretation: Larger values may indicate noisier data. Compare relative
%         to other recordings in the same study.
%
%   --- Spectral Metrics ---
%   .high_freq_noise_ratio - (numeric) Ratio of power above 40 Hz to power below 40 Hz.
%       - Interpretation: Higher values suggest more high-frequency muscle or electrical noise.
%         Values > 0.2 may warrant inspection.
%
%   .line_noise_power_...hz - (numeric) Power at the specified line frequencies.
%       - Interpretation: A measure of power-line contamination. Compare relative to
%         other recordings.
%
%   --- Window-based Quality Metric ---
%   .percent_retained_by_windows - (numeric) Percentage of data retained after window-based cleaning.
%       - Thresholds: >95% (Good), 90-95% (Acceptable), <90% (Poor)
%       - Interpretation: A measure of "raw-data" quality before ASR correction.
%   .percent_rejected_by_windows - (numeric) Percentage of data rejected by window-based cleaning.
%       - Interpretation: 100 - percent_retained_by_windows.
%
% Examples:
%
%   % --- After a preprocessing pipeline ---
%   % Assume `EEG_processed` is the output of a pipeline that included bad
%   % channel and epoch rejection.
%   quality_metrics = utils.calculate_data_quality(EEG_processed);
%   disp('Data Quality Report:');
%   disp(quality_metrics);
%
%   % --- Specifying a different line frequency ---
%   quality_metrics_50hz = utils.calculate_data_quality(EEG, 'line_freqs', [50]);
%   disp(quality_metrics_50hz);
%
%   % --- Customizing window-based cleaning and excluding channels ---
%   quality_metrics_custom = utils.calculate_data_quality(EEG, ...
%       'chan_exclude', {'EOG1', 'M2'}, ...
%       'clean_maxbadchan', 0.3, ...
%       'clean_powertol', [-4, 4]);
%   disp(quality_metrics_custom);

%% ---- Parse Name-Value inputs
p = inputParser;
p.FunctionName = 'calculate_data_quality';
addParameter(p, 'line_freqs', [50,60], @isnumeric);
addParameter(p, 'clean_maxbadchan', 0.2, @isnumeric);
addParameter(p, 'clean_powertol', [-3.5, 5], @isnumeric);
addParameter(p, 'clean_winlen', 1, @isnumeric);
addParameter(p, 'clean_winov', 0.66, @isnumeric);
addParameter(p, 'chan_exclude', {}, @iscellstr);
parse(p, varargin{:});
opt = p.Results;

quality = struct();

%% ---- Channel-based Metrics ----
if isfield(EEG, 'etc') && isfield(EEG.etc, 'EEGdojo') && isfield(EEG.etc.EEGdojo, 'BadChanSummary') && isfield(EEG, 'urchanlocs')
    num_bad_channels = EEG.etc.EEGdojo.BadChanSummary.Total;
    num_total_channels = numel(EEG.urchanlocs);
    if num_total_channels > 0
        quality.percent_bad_channels = (num_bad_channels / num_total_channels) * 100;
    else
        quality.percent_bad_channels = 0;
    end
else
    quality.percent_bad_channels = NaN;
    warning('Could not calculate percent_bad_channels. Run prep.remove_bad_channels first.');
end

%% ---- Epoch-based Metrics ----
if EEG.trials > 1
    if isfield(EEG, 'etc') && isfield(EEG.etc, 'EEGdojo') && isfield(EEG.etc.EEGdojo, 'BadEpochIdx')
        num_rejected_epochs = numel(EEG.etc.EEGdojo.BadEpochIdx);
        num_total_epochs = EEG.trials + num_rejected_epochs;
        if num_total_epochs > 0
            quality.percent_rejected_epochs = (num_rejected_epochs / num_total_epochs) * 100;
        else
            quality.percent_rejected_epochs = 0;
        end
    else
        quality.percent_rejected_epochs = NaN;
        warning('Could not calculate percent_rejected_epochs for epoched data. Run prep.remove_bad_epoch first.');
    end
else
    quality.percent_rejected_epochs = NaN; % Metric is not applicable to continuous data
end

%% ---- Handle channel exclusion for calculations ----
% here we don't do by epoch idx

EEG_calc = EEG;
if ~isempty(opt.chan_exclude)
    EEG_calc = pop_select(EEG, 'nochannel', opt.chan_exclude);
end

if numel(size(EEG_calc.data))==3
    warning('converting epoched data to continuous data for calculation')
   EEG_calc.data =  reshape(EEG_calc.data, size(EEG_calc.data,1), []);  % [nChan × (nTime*nTrials)]
end

quality.data_point_count = size(EEG_calc.data,2);


if ~isempty(EEG_calc.data)
    % Ensure data is double precision for calculations
    data = double(EEG_calc.data);

    % ---- Global Signal Metrics ----
    % Calculate Global Field Power (GFP)
    gfp = std(data, [], 1); % GFP is the standard deviation across channels at each time point
    quality.global_field_power_std = std(gfp);
    quality.global_field_power_mean = mean(gfp);
    %% ---- Amplitude Spread Proxy ---- old version only take first 1000 time point
    % This is a proxy metric for data quality based on the spread (standard deviation)
    % of the EEG signal amplitudes. Larger values may indicate noisier data.
    % Determine number of points to check (limit to 1000 points for efficiency)
    max_points = min(1000, size(EEG_calc.data,2));
    
    % Extract data for computation
    data_subset = data(:, 1:max_points);

    % Compute standard deviation for each channel
    channel_stds = std(data_subset, 0, 2);  % Standard deviation across time

    % Sort standard deviations and remove extreme values (trim the first and last)
    sorted_stds = sort(channel_stds);
    if length(sorted_stds) > 2
        trimmed_stds = sorted_stds(2:end-1); % Trim one channel from both ends
    else
        trimmed_stds = sorted_stds; % Not enough data to trim
    end
    
    % Compute the mean of trimmed standard deviations
    mean_std = mean(trimmed_stds);
    
    % Derive quality index as a "spacing value"
    quality_index = mean_std * 3; % Multiplier to estimate spread  
    quality.amplitude_spread_1k = quality_index;


    %% ---- Amplitude Spread Proxy (new) ----
    % Proxy metric for data quality based on the spread (std) of EEG amplitudes.
    % Larger values may indicate noisier data.
    % Improvements:
    %   1. Evenly subsample across the entire recording (not just the start).
    %   2. Compute stds within windows and take the median (robust to bursts).
    %   3. Use trimmed mean across channels to reduce impact of outliers.

    % Parameters
    max_points   = min(5000, size(EEG_calc.data,2));  % up to 5k points for efficiency
    n_windows    = 5;       % number of windows to sample across recording
    trim_percent = 5;       % % to trim when averaging channel stds

    % Build evenly spaced indices across the recording
    total_points = size(EEG_calc.data,2);
    idx = round(linspace(1, total_points, max_points));

    % Subsample data
    data_subset = data(:, idx);

    % Divide into windows
    win_len = floor(size(data_subset,2) / n_windows);
    win_stds = zeros(size(data_subset,1), n_windows);

    for w = 1:n_windows
        cols = (1:win_len) + (w-1)*win_len;
        if max(cols) <= size(data_subset,2)
            win_stds(:,w) = std(data_subset(:, cols), 0, 2);
        end
    end

    % Median across windows per channel
    channel_stds = median(win_stds, 2, 'omitnan');

    % Trimmed mean across channels
    mean_std = trimmean(channel_stds, trim_percent);

    % Derive quality index as a "spacing value"
    quality_index = mean_std * 3;

    quality.amplitude_spread_global = quality_index;

    %% ---- Spectral Metrics ----
    if EEG_calc.srate > 0
        % Calculate power spectral density using Welch's method
        % We use pwelch for more stable estimates than periodogram
        nfft = 2^nextpow2(EEG_calc.srate * 2); % 2 seconds of data for FFT
        [psd, freqs] = pwelch(data', hanning(nfft), nfft/2, nfft, EEG_calc.srate);
        
        % Average PSD across channels
        mean_psd = mean(psd, 2);
        
        % High-frequency noise ratio
        low_freq_mask = freqs < 40;
        high_freq_mask = freqs >= 40;
        
        power_low = trapz(freqs(low_freq_mask), mean_psd(low_freq_mask));
        power_high = trapz(freqs(high_freq_mask), mean_psd(high_freq_mask));
        
        if power_low > 0
            quality.high_freq_noise_ratio = power_high / power_low;
        else
            quality.high_freq_noise_ratio = NaN;
        end
        
        % Line noise power
        for i = 1:numel(opt.line_freqs)
            f = opt.line_freqs(i);
            [~, idx] = min(abs(freqs - f));
            power_val = mean_psd(idx);
            quality.(sprintf('line_noise_power_%dHz', round(f))) = power_val;
        end
    else
        quality.high_freq_noise_ratio = NaN;
        for i = 1:numel(opt.line_freqs)
            f = opt.line_freqs(i);
            quality.(sprintf('line_noise_power_%dHz', round(f))) = NaN;
        end
    end


%% 1/f index
[slope_mean, ~] = aperiodic_slope(EEG_calc.data, EEG_calc.srate, [2 40]);
quality.aperiodic_slope_mean = slope_mean;

    %% ---- Window-based Quality Metric ----
    % This metric calculates the percentage of data retained after window-based rejection
    % using the clean_windows function. It reflects the amount of "good" data
    % before any ASR-style correction.
    try
        % Call clean_windows to get the mask of clean samples.
        [~, sample_mask] = clean_windows(EEG_calc, opt.clean_maxbadchan, opt.clean_powertol, opt.clean_winlen, opt.clean_winov);

        % Compute percentages
        if ~isempty(sample_mask)
            mask = sample_mask(:); % 1=good, 0=bad
            quality.percent_retained_by_windows = 100 * mean(mask);
            quality.percent_rejected_by_windows = 100 * (1 - mean(mask));
        else
            warning('clean_windows returned an empty mask.');
            quality.percent_retained_by_windows = NaN;
            quality.percent_rejected_by_windows = NaN;
        end

    catch ME
        quality.percent_retained_by_windows = NaN;
        quality.percent_rejected_by_windows = NaN;
        error(ME.message);
    end
else
    quality.global_field_power_std = NaN;
    quality.amplitude_spread_proxy = NaN;
    quality.high_freq_noise_ratio = NaN;
    for i = 1:numel(opt.line_freqs)
        f = opt.line_freqs(i);
        quality.(sprintf('line_noise_power_%dHz', round(f))) = NaN;
    end
    quality.percent_retained_by_windows = NaN;
    quality.percent_rejected_by_windows = NaN;
end

end

function [slope_mean, slopes, f_fit] = aperiodic_slope(data, fs, frange, notchHz)
% Aperiodic (1/f) slope via log–log linear fit, vectorized over channels.
% data:  [nChan x nTime]
% fs:    sampling rate (Hz)
% frange: [fmin fmax] for fit (e.g., [2 40])
% notchHz: scalar 50 or 60 to exclude ±1 Hz around line noise harmonics (optional)

if nargin < 3 || isempty(frange),  frange = [2 40]; end
if nargin < 4, notchHz = []; end

% --- PSD (Welch) ---
% (Use 2 s windows; adjust if needed)
win = round(2*fs); 
[pxx, f] = pwelch(data.', hamming(win), [], [], fs, 'psd');  % pxx: [nFreq x nChan]

% --- Fit mask (frequency range + notch exclusion) ---
fitMask = (f >= frange(1) & f <= frange(2));
if ~isempty(notchHz)
    harm = notchHz:notchHz:floor(frange(2));
    excl = false(size(f));
    for h = harm
        excl = excl | (f >= h-1 & f <= h+1);
    end
    fitMask = fitMask & ~excl;
end

f_fit = f(fitMask);
lf = log10(f_fit);                       % [nFit x 1]
LP = log10(pxx(fitMask, :));             % [nFit x nChan]

% --- Vectorized linear regression: logP = a + b*logF ---
% Build design X = [1, logF]
X = [ones(numel(lf),1) lf];              % [nFit x 2]
% Solve for all channels at once via least squares
% beta = (X'X)\(X'Y) is equivalent to X\Y for full-rank X
beta = X \ LP;                           % [2 x nChan], rows: [intercept; slope]

slopes = beta(2, :).';                   % [nChan x 1]
slope_mean = mean(slopes, 'omitnan');
end
